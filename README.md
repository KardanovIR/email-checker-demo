

Условия:
> Предположим, что у Вас есть MySQL база e-mail адресов порядка 500т записей
  i_id int auto increment
  m_mail varchar(255) uniq
  В этой базе содержатся как реальные так и адреса с ошибками (символы в кириллице,
  несуществующие адреса), например: info@zerotech.ru, test@gmails.com, loremабв@gdg
  и т.д.
  Больше половины из адресов принадлежат 10-ти популярным бесплатным почтовым
  сервисам.
  Необходимо провести верификацию всех адресов, в том числе на существование
  домена и существование e-mail на этом почтовом сервере.
>  1) Опишите шаги по проверке всей базы e-mail адресов.
>  2) Создайте класс по серийной* обработке e-mail адресов (php, mysql).
>  Если какой-то этап покажется слишком сложным — оставьте комментарий в
>  теле функции.
>  3) Опишите возможные проблемы на каждом этапе.
>  4) Укажите затраченное время на реализацию задачи.
> 
>  Структуру таблиц можно изменять по усмотрению, в том числе создавать новые
>  таблицы.
>  
>  * Cерийная — это групповые операции. Чем меньше действий с БД, тем лучше. Нужно
  понимать, что данных там много, поэтому на уровне запросов должны быть
  ограничения и различные подходы по минимизации типичных операций с e-mail
  адресами.

Проверка валидности email будет состоять из 3 шагов:
1) **Проверка синтаксиса адреса в соответствии с RFC 822.** На 100% соответствие проверять не будем, чтобы не изобретать велосипед в виде регулярок (https://mathiasbynens.be/demo/url-regex) обойдемся встроенными средствами PHP.
2) **Проверка валидности домена адреса (с помощью DNS)**. Дополнительно можно проверять наличие MX записей. 
3) **Проверка существования конкретного email на этом сервере.** С большОй долей вероятности можно осуществить только отправив туда email и посмотрев ответ сервера (в данном решении не реализовано).

Описание решения:
- Для уменьшения количества запросов к БД будем читать, обрабатывать и записывать данные batch'ами. 
- Проверку валидности доменов (проверку по DNS) будем кэшировать в переменной.
- Несмотря на то, что задание тестовое, будем использовать простейший SQL Query Builder (полноценный ORM таскать не будем) - зависимость указана в `composer.json`.
- Желательно создать дополнительную таблицу, в которой записывали бы результат проверки (хотя бы булевое значение валидности), а в идеале причину, по которой не прошла проверку на валидность.
```$sql
    CREATE TABLE validation (
        id INT NOT NULL,
        email_id INT NOT NULL,
        is_valid BOOLEAN DEFAULT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP(),
        PRIMARY KEY (id),
        FOREIGN KEY emails(email_id)
    ) ENGINE=INNODB;

```